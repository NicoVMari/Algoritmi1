Spiegami le seguenti funzioni in modo tale che sia in grado di risolvere esercizi simili a questi:

void any_copy(void *dest, const void *src, size_t n)
{
  char *d = (char *) dest;
  const char *s = (const char *) src;
  for (size_t i = 0; i < n; i++) {
      d[i] = s[i];
  }
}

void *binary_search(const void *key, const void *base, size_t num_elem, size_t elem_size, int (*compar)(const void *, const void *))
{
  const unsigned char *pcb = base;
  size_t lo;
  size_t hi;
  void *ret = NULL;
  assert( key != NULL );
  assert( base != NULL );
  assert( compar != NULL );
  /*
  * Make sure the number of elements is > 0 to avoid underflow problems when
  * initializing the 'hi' variable
  */
  if (num_elem == 0)
  {
    return NULL;
  }
  lo = 0;
  hi = num_elem-1;
  while (lo <= hi && ret == NULL)
  {
    size_t mid = (lo+hi)/2;
    const void *pmid = pcb + mid*elem_size; // -> &base[mid]
    int cmp;
    cmp = compar(key, pmid);
    if (cmp == 0)
    {
      ret = (void*) pmid; // A cast is needed because we are casting from a const
      //pointer to a non-const pointer.
    }
    else if (cmp < 0)
    {
      hi = mid-1;
    }
    else if (cmp > 0)
    {
      lo = mid+1;
    }
    /*
    * At the beginning of each iteration, it may happen that both 'lo' and
    * 'hi' are 0, thus resulting in mid == 0.
    * This means that when 'hi' is updated (i.e., hi=mid-1), we incur in an
    * underflow and the function may access to an invalid memory region.
    * To avoid this, we check for the condition mid == 0 and when true we
    * break the loop.
    */
    if (mid == 0)
    {
      break;
    }
  }
  return ret;
}

void dump_array(const void *base, size_t num_elem, size_t elem_size, void (*dump_element)(const void *, FILE *), FILE *fp)
{
  const char *b = (const char *) base;

  for (size_t i = 0; i < num_elem; i++) {
      dump_element((const void *) (b + i * elem_size), fp);
  }
}

void dump_int(const void *p, FILE *fp)
{
     fprintf(fp, "%d ", *(const int *)p);
}

void dump_string(const void *p, FILE *fp)
{
    fprintf(fp, "%s ", (const char *)p);
}

La funzione any_copy() prende come argomenti tre parametri: un puntatore a una destinazione, un puntatore a una sorgente e una dimensione. La funzione copia i dati dalla sorgente alla destinazione, byte per byte, per un numero di byte specificato dalla dimensione.

La funzione binary_search() prende come argomenti: un puntatore a un elemento chiave, un puntatore a un array di base, il numero di elementi nell'array, la dimensione di un singolo elemento e un puntatore a una funzione di confronto. La funzione esegue una ricerca binaria sull'array per trovare l'elemento corrispondente alla chiave fornita e restituisce un puntatore all'elemento trovato.

La funzione dump_array() prende come argomenti: un puntatore all'array di base, il numero di elementi nell'array, la dimensione di un singolo elemento e un puntatore a una funzione di dump. La funzione scorre l'array, passando ogni elemento alla funzione di dump per la stampa.

La funzione dump_int() prende come argomenti un puntatore a un intero e un puntatore a un file, e stampa il valore dell'intero sulla posizione del file.

La funzione dump_string() prende come argomenti un puntatore a una stringa e un puntatore a un file, e stampa la stringa sulla posizione del file.
